1.volatile（喂了泰尔）是java虚拟机提供的轻量级的同步机制

三大特性：保证可见性，不保证原子性，禁止指令重排

可见性：我们多个线程访问同一个变量的时候，其实是从主内存里copy了一份到各自的工作内存（栈空间），当其中一个线程改了该变量的值（读取赋值操作必须在工作内存中进行），会将改变的值回写到主内存。然后由主内存告诉其他线程这个值已经被改变，
你们需要重新获取，这个叫做可见性。

原子性：不可分割，完整性，就是一个线程正在做某个具体业务的时候，不可以被加塞或者分割（别的线程过来干预）

禁止指令重排：单线程环境下确保程序最终执行的结果与代码顺序执行的结果一致，多线程环境中，线程交替执行，由于编译器优化重排，多个线程中使用的变量能否保持一致性是无法确认的，
所以volatile禁止指令重排，从而避免多线程环境下程序出现乱序执行的现象，保证多线程环境下，程序最终的执行结果与代码顺序执行的结果一致。

2.JMM（java内存模型）
	本身是一个抽象的概念并不真实存在，它是一组 规则或规范，通过这组规范定义了程序中的各个变量（包括实例字段，静态字段，和构成数组对象的元素）的访问方式
1.可见性
2.原子性：不可分割，完整性，就是一个线程正在做某个具体业务的时候，不可以被加塞或者分割（别的线程过来干预）
3.有序性

JMM关于同步的规定：
1.线程解锁前，必须把共享变量的值刷新回主内存
2.线程加锁前，必须读取主内存的最新值到自己的工作内存
3.加锁解锁是同一把锁


1.什么时候使用volatile，举个例子

我们在写一个单例模式的时候，在多线程下也会创建多个对象，我们这个时候，需要给初始化方法加同步，直接加sync同步修饰的话，会减少并发量，这个时候我们可以用DCL（双端检索机制）来初始化。
但是这个时候可能会指令重排导致线程不安全，所以这个时候就可以给变量加上volatile修饰符保证线程安全
