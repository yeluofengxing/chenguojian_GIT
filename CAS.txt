1.CAS是什么
比较并交换：原子类引用了unsale的cas，有几个参数，期望值和更新值，当一个线程执行的时候，会将期望值从主内存copy到自己的工作空间进行操作，将期望值改为更新值，然后写回到主内存，写的时候比较期望值和主内存的值是否一致
一致的情况下，说明值还没有被其他线程更改，这个时候可以给更改过的值写回到主内存，否则失败不允许写回，再次获取，进行判断直到成功再回写到主内存。保证了原子性。有点类似于SVN，GIT的版本提交
CAS底层实现原子性，是通过访问Unsafe的cas方法，JVM会帮我们实现出CAS汇编指令，这个一种完全依赖硬件的功能，通过它来实现了原子操作。因为CAS是一种系统原语，执行过程中不允许被中断，所以不会造成数据不一致的问题。

cas的缺点：
循环时间长，开销大，不加锁，并发量不影响，但是会循环比较，如果cas长时间一直不成功，可能会给CPU带来很大的开销
只能保证一个共享变量的操作：对于多个共享变量的操作，cas无法保证一个，可以加锁来实现多个

引出来ABA问题：CAS会将期望值和主内存进行比较，如果相同，他会认为没有被人改过。但是如果在这个过程中，有别的线程改了主内存的值，又改回去，这个时候，cas不知道，还是会执行成功，这个过程是有问题。
原子引用：JUC 提供了atomicReference<T> T可以支持各种类型的对象原子化
ABA问题解决：加一个时间戳，可以用JUC提供的 atomiscStamepedReference
	