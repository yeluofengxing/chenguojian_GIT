1.公平锁与非公平锁
ReentrantLock（瑞安踹特 咯k）  可冲入锁（非公平） 加参数 new ReentranLock（true）公平锁

公平锁：排序（先申请的先获取锁），效率比非公平锁低（顺序得到保障，效率下降）  （多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到）
            很公平，在并发环境中，每个线程在获取锁的时候会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占用锁，否则加入等待队列中，先进先出

非公平锁：没有顺序（后申请的可以先获得锁），效率高（是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象（可能先申请的一致获取不到锁，被一直加塞））
             非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，才会采用类似公平锁的那种方式来获取锁
对于Synchronized来收，也是一种非公平锁

2.可重入锁（又名递归锁）
指的是同一线程外层函数获取锁之后，内层递归函数仍然能获取到该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，线程可以进入任何一个它已经拥有的锁所同步的代码块
也就是两个同步方法，A，B，A里面调用了B，那么只要获得了A的锁，那线程就可以自动获取B的锁（直接进入B方法），ReentrantLock/Synchronized就是典型的可重入锁
可重入锁的最大用处：避免死锁

3. 自旋锁（spinLock）相当于 while 加cas
是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会占用过多的CPU资源，像原子类的 cas 就是用的自选去比较

4. 独占锁（写锁）/共享锁（读锁）/互斥锁
独占锁：指该锁只能被一个线程所持有，对于ReentrantLock 和synchroinzed而言都是多占锁
共享锁：指该锁可以被多个线程所持有，对ReentrantReadWriteLock来说，其读锁是共享锁，其写锁是独占锁。
读锁的共享锁可以保证并发读是非常高效的，读写，写读，写写的过程是互斥的。写操作独占不能中断，读共享
读写锁用于提供业务的并发性

5.乐观锁/悲观锁
乐观锁：每次读数据时认为不会被第三方修改，所以无需加锁；写数据时要判断在此期间是否有第三方修改数据。
乐观锁用于多读的场景，数据库技术中常用版本号控制，乐观锁在java中通过无锁实现，最常采用的是CAS算法，JAVA原子类中的递增操作就通过CAS自旋实现
乐观锁适用读多写少的场景
悲观锁：每次操作数据时假定有第三方会修改数据，所以每次操作数据时上锁；阻塞别的线程
mySql里的表锁，行锁就是典型的悲观锁。Java中的同步synchronized关键字就是典型的悲观锁
乐观锁适用写多读少的场景

6.分段锁
分段锁表示锁的设计，不是具体的实现。
分段锁的目的是锁粒度细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
Concurrent（看卡润特）HashMap 就是通过分段锁的形式来实现高效的并发操作

Synchronized和lock有什么区别，用Lock有什么好处

1.synchroinzed是java关键字，是JVM层面，底层是用的monitorenter（摸你特）来实现的，会退出两次，正常退出，异常退出（看字节码可以看到）（保证不死锁）
lock是API层面的锁

2.synchroinzed不需要用户手动去释放锁，线程完成自动释放
lock需要手动释放

3.synchrionized不可中断，除非抛出异常或者正常运行完
ReentrantLock，可以中断 ，设置超时方法 tryLock（long timeOut，timeUnit unit），lockInteruptibly（）放代码块中，调用interrupt（）方法可中断

4.加锁是否公平
synchronized 非公平锁
ReentrantLock，两者都可以，传参控制，默认非公平锁

5.锁绑定多个条件 condition（看滴醒，唤醒）
synchronized没有
ReentRantLock，用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么全部唤醒，那么随机唤醒一个线程


用Lock有什么好处：
ReentRantLock，用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么全部唤醒，那么随机唤醒一个线程

什么是死锁，活锁，饿死？
死锁：是指多个线程在运行过程中因争夺资源而造成的一种僵局，当线程处于这种僵持状态时，若无外力作用，它们都无法继续推进

比如有两个线程A，B，A持有了A锁，B持有了B锁，线程A想去获取B锁，线程B又想去获取A锁，这个时候就会死锁

活锁：是指线程1可以使用资源，让其他线程先用，其他线程也这样让，最后这几个线程都无法使用资源
饿死：非公平锁中 多个线程在等待资源的时候，一个来了很久的线程一直获取不到锁，反而是让后面来得线程获取到锁

死锁的条件：4个条件都满足才会死锁
1.互斥:共享资源（锁）被竞争性的访问，共享资源同一时刻只能被一个线程占用
2.持有并等待：线程持有已经分配给它们的资源，同时等待其他的资源
3.资源不可剥夺。线程已经获取到资源不会被其他线程强制抢占
4.循环等待：线程之前存在资源的环形依赖链，每个线程都依赖于链条中的下一个线程释放必要的资源，而链条的末尾又依赖链条头部的线程，进入了一个循环等待的状态

如何避免死锁
死锁是由四个必要条件导致的，所以只要破坏其中一个条件，死锁情况就不会发生
1.如果想要打破互斥条件，需要允许线程同时访问某些资源，这种方法受制于实际场景，不容易实现
2.线程在运行前申请得到的所有的资源，否则该线程不能进入准备执行状态，这个方法看似有点用处，但是它的缺点是可能导致资源利用率和线程并发性降低
3.打破不可抢占条件，需要允许线程强行从占有者哪里夺取某些资源
4.避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了线程对资源的占有时间

在有些情况下死锁是可以避免的。三种用于避免死锁的技术：
加锁顺序（线程按照一定的顺序加锁）
加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
死锁检测（找到那些线程死锁了，逐步撤销参与死锁的线程，逐步收回死锁线程占有的资源）